# -*- coding: utf-8 -*-
"""Content-based.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hQ4wJmqR1HzDuhBzDgWxB6zg4cxlKACk

## Import Library
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer

"""## Load Dataset"""

movies = pd.read_csv("movie.csv")
tags = pd.read_csv("genome_tags.csv")
scores = pd.read_csv("genome_scores.csv")

print('Jumlah data film yang tersedia: ', len(movies.movieId.unique()))
print('Jumlah tag unik: ', len(tags.tagId.unique()))
print('Jumlah skor relevansi: ', len(scores))

"""## EDA
Tahap eksplorasi penting untuk memahami variabel-variabel pada data serta korelasi antar variabel. Pemahaman terhadap variabel pada data dan korelasinya akan membantu kita dalam menentukan pendekatan atau algoritma yang cocok untuk data kita.
"""

movies.info()

movies.head()

tags.info()

scores.info()

"""## Data Preparation
Pada tahap data preparation, dilakukan penggabungan dan transformasi data tag agar setiap film memiliki representasi teks yang merefleksikan kontennya berdasarkan tag relevan, yang kemudian digunakan untuk proses vektorisasi dan perhitungan kemiripan.

"""

print("\nCek missing value:")
print("Movies:")
print(movies.isnull().sum())
print("Tags:")
print(tags.isnull().sum())
print("Scores:")
print(scores.isnull().sum())

"""### Mengecek apakah ada nilai kosong (missing value) dalam masing-masing dataset. Ini penting sebelum proses pemodelan. Disini tidak terdapat missing value"""

tag_data = scores.merge(tags, on="tagId")

"""### Menggabungkan scores dan tags berdasarkan tagId sehingga setiap baris menyertakan movieId, tag, dan relevance. Ini adalah fondasi untuk representasi konten film."""

film_tag_repr = tag_data.groupby("movieId").apply(lambda x: ' '.join(
    x.sort_values("relevance", ascending=False).head(20)["tag"].values))
film_tag_repr = film_tag_repr.reset_index()
film_tag_repr.columns = ["movieId", "tags"]

"""### Membuat representasi teks (tag) untuk setiap film:
- Mengambil 20 tag teratas berdasarkan relevansi.
- Menggabungkannya menjadi satu string per film.
- Output: DataFrame dengan movieId dan teks tags.
"""

movies = movies.merge(film_tag_repr, on="movieId")

"""### Menambahkan kolom tags hasil dari proses sebelumnya ke dalam DataFrame movies. Sekarang setiap film memiliki deskripsi berbasis tag.


"""

vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(movies['tags'])

"""### Mengubah kolom tags menjadi matriks TF-IDF (representasi numerik) yang akan digunakan untuk menghitung kemiripan antar film."""

cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

cosine_df = pd.DataFrame(cosine_sim, index=movies['title'], columns=movies['title'])
cosine_df.iloc[:5, :5]

"""### Menghitung matriks kemiripan kosinus antar semua film berdasarkan vektor TF-IDF mereka. Semakin besar nilai, semakin mirip dua film tersebut.

## Membuat Fungsi Rekomendasi
### Fungsi utama sistem rekomendasi:
- Menerima judul film dan jumlah rekomendasi.
- Mencari film paling mirip berdasarkan nilai kemiripan kosinus.
"""

indices = pd.Series(movies.index, index=movies['title']).drop_duplicates()

def rekomendasikan_film(judul, n=5):
    if judul not in indices:
        return f"Film '{judul}' tidak ditemukan dalam dataset."
    idx = indices[judul]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
    sim_scores = sim_scores[1:n+1]  # Skip film itu sendiri
    film_indices = [i[0] for i in sim_scores]
    return movies['title'].iloc[film_indices].tolist()

print("Rekomendasi untuk 'Toy Story (1995)':")
print(rekomendasikan_film("Toy Story (1995)"))

"""### Menguji fungsi rekomendasi dengan film “Toy Story (1995)” untuk melihat film-film yang paling mirip berdasarkan kontennya.

## Evaluasi
- Evaluasi dilakukan secara kualitatif dengan melihat apakah hasil rekomendasi memang mirip secara konten.
- Uji coba beberapa film dan lihat apakah genre/tag-nya relevan terhadap input.
"""

movies[['title', 'genres']].head()

movies['genre_set'] = movies['genres'].apply(lambda x: set(x.lower().split('|')))

def evaluate_precision_at_k(top_k=5, sample_size=100):
    total_precision = 0
    count = 0

    for idx, row in movies.sample(sample_size, random_state=42).iterrows():
        judul = row['title']
        true_genres = row['genre_set']

        rekomendasi = rekomendasikan_film(judul, n=top_k)

        if isinstance(rekomendasi, str):  # artinya film tidak ditemukan
            continue

        overlap_count = 0
        for rec_title in rekomendasi:
            rec_genres = movies[movies['title'] == rec_title]['genre_set'].values
            if len(rec_genres) == 0:
                continue
            rec_genres = rec_genres[0]
            if len(true_genres & rec_genres) > 0:
                overlap_count += 1

        precision = overlap_count / top_k
        total_precision += precision
        count += 1

    avg_precision = total_precision / count
    print(f"Average Precision@{top_k} (based on genre overlap): {avg_precision:.4f}")
    return avg_precision

evaluate_precision_at_k(top_k=5, sample_size=100)

test_titles = ["Toy Story (1995)", "Jumanji (1995)", "Heat (1995)"]

for title in test_titles:
    print(f"\nRekomendasi untuk '{title}':")
    print(rekomendasikan_film(title))

